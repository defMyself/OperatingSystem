# 进程同步

## 概念

进程同步：并发进程在关键节点上需要互相等待或互通消息，相互制约等待或互通消息称为进程同步。

**关键节点相互等待或通信**

同步机制应当遵循的原则：

* 空闲让进： 其他进程均不处于临界区，任意进程可以进入
* 忙则等待：已有进程处于其临界区，其他进程不能进入
* 有限等待：等待进入临界区的进程不能死等
* 让权等待：不能进入临界区的进程，应该释放CPU

### 互斥的实现

#### 软件算法实现互斥

* 算法1： 两个进程P0, P1共享某临界资源
* 设置一个公用整型变量turn， 描述允许进入临界区的进程标识，假设初始化为0
* 表示首先轮到P0访问临界资源

```c
int turn = 0;

void P0() {
    while(turn != 0);
	//
    turn = 1;
}

void P1() {
    while(turn != 1);
    // 
    turn = 0;
}
```

算法分析：

* 初始化设置P0先访问，P1先申请就不能执行，不符合空闲让进
* 当turn为1，P0进程会执行空循环等待（而不是挂起），直到turn变成0，违背让权等待
* 忙则等待符合
* 有限等待符合



* 算法2：设置一个标志数组flag[2]: 描述进程是否已在临界区，初值为0
* 违背忙则等待原则

**多进程模型的一个特点是，进程在每一条语句执行完后可能时间片结束**



### 锁机制实现互斥

* 锁的定义： 用变量w代表某种资源的状态，w称为锁
* 上锁与开锁
  * 上锁---临界资源的申请
    * 检测w的值
    * 1，继续检测
    * 0，将锁置1，进入临界区执行
  * 开锁操作
    * 临界资源使用完毕，将锁置1
  * 上锁原语和开锁原语



### 信号量机制

* 信号量数据结构定义

```c
typedef struct {
    int value;	// 信号量的值
    PCB * L;	// 进程等待队列队首指针
}
```

* value: 初始化为非负整数值，表示空闲资源总数
  * 非负值表示当前空闲资源数
  * 负值表示当前等待临界资源的进程个数
* L: 初值为空
* 信号量的P, V操作： semaphore *S;
  * P操作（临界资源申请操作）
  * V操作（临界资源释放操作）

```c
V(S) {
    S->value++;			// 归还一个临界资源给系统
    if(S->value<=0)
        wakeup(S->L);	// 唤醒进程
}
```

```c
P(S) {
    S->value--;			// 
    if(S->value<0);	
    	sleep(S->L);	// 由于进程不能申请到临界资源时是主动释放CPU,并且阻塞到L链表上
						// 所以信号量实现了让权等待原则
}	
```

### 利用信号量机制实现进程互斥与同步

